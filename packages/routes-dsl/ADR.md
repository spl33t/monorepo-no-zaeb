# ADR: Routes DSL для SPA-приложений

## Статус
Принято

## Контекст

В SPA-приложениях маршруты описываются в разных местах:
- Router конфигурация
- Guards для доступа
- SEO метаданные
- Sitemap генерация
- Меню навигации

Это приводит к проблемам:
1. **Нет единого источника истины** - маршруты дублируются
2. **Плохая типизация** - URL параметры не типизированы
3. **Runtime зависимость** - доступ зависит от асинхронного контекста (user, roles)
4. **Плохая переиспользуемость** - сложно использовать между SPA, edge, SEO

Существующие роутеры (React Router, TanStack Router) решают навигацию, но не решают задачу декларативного описания маршрутов как доменной модели.

## Решение

Создать **DSL (Domain Specific Language)** для маршрутов, который:

### Ключевые принципы

1. **Двухшаговая инициализация**
   - Сначала создаётся фабрика с глобальным контекстом
   - Затем через фабрику описываются маршруты

2. **Декларативность**
   - Маршруты описываются как данные, а не логика
   - Один объект маршрутов для всего проекта

3. **Типобезопасность**
   - Полная типизация URL и параметров
   - TypeScript выводит типы автоматически

4. **Контекстная зависимость**
   - Поведение зависит от user / roles / окружения
   - Без if'ов в компонентах

5. **Переиспользуемость**
   - Один DSL для SPA, edge, SEO, sitemap
   - Не привязан к конкретному роутеру

### Архитектура

```
┌─────────────────────────────────────┐
│   Routes DSL (Domain Model)         │
│   - Route definitions               │
│   - Access control                  │
│   - SEO metadata                    │
│   - Context management              │
└─────────────────────────────────────┘
              │
              ├───> React Router (UI)
              ├───> Edge/SSR (SEO)
              ├───> Sitemap Generator
              └───> Access Matrix
```

DSL находится **над** роутером, а не заменяет его.

### Что включает маршрут

- `path` - URL паттерн
- `params` - типизированные параметры из URL
- `access` - функция доступа на основе контекста
- `seo` - генератор title / meta
- `redirect` - логика перенаправления
- `cache` - инфраструктурные атрибуты
- `meta` - дополнительные метаданные

### Что делает DSL-движок

1. Нормализует маршруты
2. Добавляет runtime-методы (`url()`, `access()`)
3. Связывает декларацию с контекстом пользователя
4. Генерирует производные структуры:
   - Sitemap
   - SEO manifest
   - Access matrix
   - Документацию

## Последствия

### Положительные

✅ **Единый источник истины** - все маршруты в одном месте
✅ **Типобезопасность** - TypeScript проверяет URL и параметры
✅ **Декларативность** - маршруты как данные, легко читать
✅ **Контекстная логика** - доступ без if'ов в компонентах
✅ **Переиспользуемость** - один DSL для всех платформ
✅ **Тестируемость** - маршруты легко тестировать

### Отрицательные

❌ **Дополнительный слой абстракции** - нужно понимать DSL
❌ **Кривая обучения** - разработчикам нужно изучить API
❌ **Размер бандла** - дополнительный код (но минимальный)

### Риски

⚠️ **Сложность интеграции** - нужно интегрировать с существующими роутерами
⚠️ **Поддержка** - нужно поддерживать DSL и обновлять под новые требования

## Альтернативы

### 1. Использовать существующие роутеры напрямую

**Проблемы:**
- Нет единого источника истины
- Плохая типизация параметров
- Дублирование логики доступа

### 2. Создать утилиты поверх роутера

**Проблемы:**
- Не решает проблему декларативности
- Все равно нужна типизация
- Сложно переиспользовать между платформами

### 3. Использовать code generation

**Проблемы:**
- Сложность настройки
- Медленная разработка (нужен rebuild)
- Сложнее отлаживать

## Реализация

### API Design

```typescript
// Step 1: Create factory
const createRoutes = createRoutesFactory({
  user: $user<User>(),
  roles: ['user', 'admin'],
  env: 'production',
});

// Step 2: Define routes
const routes = createRoutes({
  profile: {
    path: '/profile/:id',
    access: Access.authenticated,
    seo: SEO.dynamic((params) => ({
      title: `Profile ${params.id}`,
    })),
  },
});

// Usage
routes.profile.url({ id: '123' }); // Type-safe!
routes.profile.access(); // Context-aware
```

### Интеграция

DSL не заменяет роутер, а работает с ним:

```typescript
// Convert DSL routes to router config
const routerConfig = routes.all().map((route) => ({
  path: route.path,
  element: <RouteWrapper route={route} />,
}));
```

## Метрики успеха

- ✅ Все маршруты описаны в одном месте
- ✅ TypeScript проверяет типы URL параметров
- ✅ Доступ контролируется декларативно
- ✅ SEO метаданные генерируются автоматически
- ✅ Sitemap генерируется из DSL
- ✅ Один DSL используется в SPA и edge

## Ссылки

- [README.md](./README.md) - Документация API
- [example.ts](./src/example.ts) - Примеры использования




